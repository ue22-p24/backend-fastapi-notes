## !intro a notes app in FastAPI step by step

**Warning**:  
[the final code is available at this repo](https://github.com/ue22-p24/backend-fastapi-notes-steps)
(as well as all the steps in the successive commits)

so, our goal here is to show **why** we're doing things, and **in what order**  
**do not try** to apply these successive **changes yourself** in the code !  
This would be very time-consuming, you would find yourself spending all your time doing cut-and-paste,
and that's not the goal here :)


### step 00: the starter code

the starter code in step 00 is the basic FastAPI `hello world` app

```python main.py
!from ../main-00.py
```

that you start from the terminal with:

```bash
fastapi run --reload
```

By default this uses port 8000, so no need to specify it even on MacOS (where port 5000, the Flask default, is used by a system service)

## !!steps 01a: using a database
### 00 -> 01a - changes in main.py
#### create a database with sqlmodel using a lifespan

we import the `sqlmodel` module; and in order to create the database, we define the `lifespan` function.

FastAPI expects this function to be a generator function; this allows to define the application prolog and epilog
(the prolog is executed before the first `yield` statement, and the epilog is executed after that point)

Note how the `app` variable is created by passing the `lifespan` function to the `FastAPI` constructor.

With this version, the database is created and populated when the application starts (although at this point the database is empty)
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:5) +
# !diff(7:7) +
# !diff(8:8) -
# !diff(9:25) +
........
VERSION = "00"
VERSION = "01a"

from contextlib import asynccontextmanager
from fastapi import FastAPI
from sqlmodel import SQLModel, create_engine
app = FastAPI()
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)

# this is how we control what is done at startup and shutdown
@asynccontextmanager
async def lifespan(app: FastAPI):
    # startup logic comes here
    # Create the database and tables if they don't exist
    SQLModel.metadata.create_all(engine)

    yield
    # shutdown logic comes here
    # none so far


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
@app.get("/")
```

## !!steps 01b: a DB session
### 01a -> 01b - changes in main.py
#### defining SessionDep for interacting with the DB

this is boilerplate code to expose a session object, which we'll need to
actually talk to the database

it's interesting to note: this pattern is called "dependency injection"; the
`SessionDep` object allows to reference a session object even though we **do not
explicitly create it**; by defining `get_session`, we just explain **how to
create it**, the framework will ensure its creation will happen before the first
use
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !diff(5:5) +
# !diff(7:8) +
# !diff(10:10) +
# !className(13) separator
# !diff(15:22) +
........
VERSION = "01a"
VERSION = "01b"
from contextlib import asynccontextmanager
from typing import Annotated
from fastapi import FastAPI
from fastapi import Depends

from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
    # none so far
# create a so-called "dependency" to get the database session
def get_session():
    with Session(engine) as session:
        yield session

SessionDep = Annotated[Session, Depends(get_session)]


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
```

## !!steps 02a: POST /api/notes to create notes
### 01b -> 02a - changes in main.py
#### a table to store notes, and an API endpoint to create them

this is typical code to create a table in a database; note the `table=True` passed to the `Note` class  
this is what defines the actual set of columns in the database table

as far as the API is concerned, we define a `POST` endpoint to create a note  
in particular, note how minimal the code is; we  don't need to make any check on
the incoming data, it will automatically be checked for consistency; and the
framework does that based on the `note: Note` argument type  
generally speaking, FastAPI will automatically check the types of the arguments,
based on such *type hints*, and will return a 422 error if the types do not
match  
similarly, having typed the return value of the function as `Note`, FastAPI will
automatically convert the returned object to JSON, and set the appropriate HTTP
status code (201)
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !className(6) separator
# !diff(9:9) +
# !className(12) separator
# !diff(14:20) +
# !className(23) separator
# !diff(27:38) +
........
VERSION = "01b"
VERSION = "02a"
from contextlib import asynccontextmanager
from typing import Annotated
........
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
from sqlmodel import Field
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
SessionDep = Annotated[Session, Depends(get_session)]
class Note(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    description: str
    done: bool = False


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
........
async def root():
    return dict(message="Hello FastAPI World!",
                version=VERSION)

"""
http :8000/api/notes title="Devoirs" description="TP Backend"
http :8000/api/notes title="Papiers" description="Nouveau Passeport"
http :8000/api/notes title="Dentiste" description="ouille !" done:=true
"""
@app.post("/api/notes")
def create_note(note: Note, session: SessionDep) -> Note:
    session.add(note)
    session.commit()
    session.refresh(note)
    return note
```

## !!steps 02b: GET /api/notes endpoint
### 02a -> 02b - changes in main.py
#### is that simple or what ?

we will see later on how to control the fields that are returned in the JSON response
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !className(6) separator
# !diff(10:10) +
# !className(13) separator
# !diff(17:24) +
........
VERSION = "02a"
VERSION = "02b"
from contextlib import asynccontextmanager
from typing import Annotated
........
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
from sqlmodel import Field
from sqlmodel import select
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
    session.commit()
    session.refresh(note)
    return note

"""
http :8000/api/notes
"""
@app.get("/api/notes")
def get_notes(session: SessionDep) -> list[Note]:
    notes = session.exec(select(Note)).all()
    return notes
```

## !!steps 02c: GET /api/notes/{i} endpoint
### 02b -> 02c - changes in main.py
#### how to get all the details on a specific note

as you can see, the code is as simple as it gets  
here again, FastAPI takes advantage of the type hints to automatically return a JSON-encoded dictionary,
and we control the actual set of fields exposed in the result by stating that the function returns a `Note` object
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !className(6) separator
# !diff(10:17) +
........
VERSION = "02b"
VERSION = "02c"
from contextlib import asynccontextmanager
from typing import Annotated
........
def get_notes(session: SessionDep) -> list[Note]:
    notes = session.exec(select(Note)).all()
    return notes

"""
http :8000/api/notes/1
"""
@app.get("/api/notes/{note_id}")
def get_note(note_id: int, session: SessionDep) -> Note | None:
    note = session.get(Note, note_id)
    return note
```

## !!steps 03a: expose /static/ folder with the CSS style
### 02c -> 03a - changes in main.py
#### how to expose static files

ok so at this point we want to expose a new endpoint, `/front/notes`, which will
return the HTML page to display, and later on interact with, the notes.

in order to do that, we need to expose some **static content**; for starters we have
a stylesheet, that we store in `static/style.css`; we're not going to detail the
CSS here, as we want to focus on the backend side of things

but it's important that the browser can access this file; and the way to do that
as shown here, by "mounting" the local `static` folder to the `/static` URL.
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !diff(8:8) +
# !className(11) separator
# !diff(15:19) +
........
VERSION = "02c"
VERSION = "03a"
from contextlib import asynccontextmanager
from typing import Annotated
from fastapi import FastAPI
from fastapi import Depends
from fastapi.staticfiles import StaticFiles
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
def get_note(note_id: int, session: SessionDep) -> Note | None:
    note = session.get(Note, note_id)
    return note

"""
http :8000/static/css/style.css
"""
app.mount("/static", StaticFiles(directory="static"), name="static")
```

## !!steps 03b (1/2): GET /front/notes returns templated HTML
### 03a -> 03b - changes in main.py
#### serve a HTML page from a Jinja template

this new `/front/notes/` endpoint will return a HTML page, which is rendered from a Jinja template

worth being noted here, is the way the data is passed from Python to the template, by setting the `context` parameter of the `render_template` function
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !className(6) separator
# !diff(10:12) +
# !className(15) separator
# !diff(19:32) +
........
VERSION = "03a"
VERSION = "03b"
from contextlib import asynccontextmanager
from typing import Annotated
........
from fastapi import FastAPI
from fastapi import Depends
from fastapi.staticfiles import StaticFiles
from fastapi import Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
http :8000/static/css/style.css
"""
app.mount("/static", StaticFiles(directory="static"), name="static")


templates = Jinja2Templates(directory="templates")

"""
http :8000/front/notes
"""
@app.get("/front/notes", response_class=HTMLResponse)
def notes_page(request: Request, session: SessionDep):
    notes = session.exec(select(Note)).all()
    return templates.TemplateResponse(
        request=request,
        name="notes.html.j2",
        context={"notes": notes})
```

## !!steps 03b (2/2): GET /front/notes returns templated HTML
### 03b : new file notes.html.j2
#### a Jinja template for notes

here's the Jinja template for the notes page;  
as you can see it's mostly HTML, with a few Jinja tags to insert the data from the FastAPI backend.

The Python code renders this template with a *context*, which is a dictionary of variables that are passed to the template.

In this template we see a few of the Jinja features in action:

### `{% for note in notes %}`

For example this template iterates over the `notes` variable, which is expected to be a list of dictionaries, each one representing a note.

Once rendered, this template will thus contain as many `<li>` elements as there are notes in the `notes` list.

### ` {{ note.title }}`

Using the `{{ ... }}` syntax, we can insert the value of a variable in the template.

### `{% if note.done %}`

We can also see in this example a use of a conditional statement.
```html ! notes.html.j2
<!-- !diff(1:26) + -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/style.css">
    <title>My todo notes</title>
</head>

<body>
    <h1>My todo notes</h1>
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
            <div class="title">{{ note.title }}</div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%} />
            </div>
        </li>
        {% endfor %}
    </ul>
</body>

</html>
```

## !!steps 04: redirect / to /front/notes
### 03b -> 04 - changes in main.py
#### a simple redirect

generally, people will just type a URL with the domain name in their browser; i.e.  
`https://awesomenotes.io/`  
and not  
`https://awesomenotes.io/front/notes`  

so it's good practice that the `/` URL redirects to the `/front/notes` URL, which is what we do here

and in order to still get a way to see the current version of the API, we pass
another variable to the template context; this is used in the `.j2` template
(not shown here) to display the current version of the API
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !className(6) separator
# !diff(10:10) +
# !className(13) separator
# !diff(16:17) -
# !diff(18:18) +
# !className(21) separator
# !diff(25:25) -
# !diff(26:26) +
........
VERSION = "03b"
VERSION = "04"
from contextlib import asynccontextmanager
from typing import Annotated
........
from fastapi.staticfiles import StaticFiles
from fastapi import Request
from fastapi.responses import HTMLResponse
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, create_engine
........
@app.get("/")
async def root():
    return dict(message="Hello FastAPI World!",
                version=VERSION)
    return RedirectResponse(url="/front/notes")
"""
http :8000/api/notes title="Devoirs" description="TP Backend"
........
    return templates.TemplateResponse(
        request=request,
        name="notes.html.j2",
        context={"notes": notes})
        context={"version": VERSION, "notes": notes})
```

## !!steps 05: PATCH /api/notes endpoint to change a note
### 04 -> 05 - changes in main.py
#### allow callers to modify a note

It's cool to be able to create a note, but we also want to be able to modify it

it is the purpose of this new `PATCH` endpoint

You can use it with `http` like shown in the comment above the endpoint

Please note in this code:

- the use of the `Body` annotation; this means that the `payload` argument is
  expected to be in the body of the request, and not in the URL or headers
- again we use the `Note` class to define the type of the payload; this means that
  FastAPI will automatically check that the incoming data is consistent with the
  `Note` class, and will return a 422 error if it is not
- also interesting, this line  

  `db_note.sqlmodel_update(payload.model_dump(exclude_unset=True))`  
  which allow us to safely update the note with the new values;  
  compare this with a tedious code were we would consider each field one by one,
  checking of that field is provided or not by the caller, and update the object
  accordingly  
  clearly this one-liner is much more readable and maintainable !
```python ! main.py
# !className(1) separator
# !diff(2:2) -
# !diff(3:3) +
# !className(6) separator
# !diff(10:10) +
# !className(13) separator
# !diff(15:16) +
# !className(20) separator
# !diff(24:46) +
........
VERSION = "04"
VERSION = "05"
from contextlib import asynccontextmanager
from typing import Annotated
........
from fastapi.responses import HTMLResponse
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi import Body
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
SessionDep = Annotated[Session, Depends(get_session)]
# for now we'll use a single type for all operations on notes
# BUT we'll see later on how to improve that
class Note(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
........
        request=request,
        name="notes.html.j2",
        context={"version": VERSION, "notes": notes})


"""
http PATCH :8000/api/notes/1 done:=true
http PATCH :8000/api/notes/1 description="TP Backend FastAPI"
"""
@app.patch("/api/notes/{note_id}", response_model=Note)
def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[Note, Body(...)],
):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # a class-independant way to do the update
    db_note.sqlmodel_update(payload.model_dump(exclude_unset=True))
    # commit the changes to the database
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    # return the updated note
    return db_note
```



## !outro conclusion

### some illustrations

![](front-users.excalidraw.svg)
![](socketio.excalidraw.svg)

### after thoughts

it seems that the choice of our endpoints is not necessarily in line with common practice;
the following renaming has been suggested:

- `/api/messages/1/` to send a message from user 1, with the other message fields (like `recipient_id`)
  passed in the POST JSON data


### further work

from this, you can now improve this code to support actual (multi-people) rooms;
2 levels of involvement can be envisioned

1. Just write the steps that would be needed, in mush the same way as above
1. and/or if you're up for it, go as far as implementing it