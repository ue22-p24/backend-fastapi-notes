## !intro a notes app in FastAPI step by step

**Warning**:  
[the final code is available at this repo](https://github.com/ue22-p24/backend-fastapi-notes-steps)
(as well as all the steps in the successive commits)

so, our goal here is to show **why** we're doing things, and **in what order**  
**do not try** to apply these successive **changes yourself** in the code !  
This would be very time-consuming, you would find yourself spending all your time doing cut-and-paste,
and that's not the goal here :)


### step 00: the starter code

the starter code in step 00 is the basic FastAPI `hello world` app

```python main.py
!from ../main-00.py
```

## !!steps 01 (1/2): creating a database with sqlmodel using a lifespan
### 00 -> 01 - changes in main.py
#### use a database

we import the `sqlmodel` module; and in order to create the database, we define the `lifespan` function.

FastAPI expects this function to be a generator function; this allows to define the application prolog and epilog
(the prolog is executed before the first `yield` statement, and the epilog is executed after that point)

Note how the `app` variable is created by passing the `lifespan` function to the `FastAPI` constructor.

With this version, the database is created and populated when the application starts (although at this point the database is empty)
```python ! main.py
# !className(1) separator
# !diff(3:4) +
# !diff(6:6) +
# !diff(7:7) -
# !diff(8:24) +
........
VERSION = "00"
from contextlib import asynccontextmanager

from fastapi import FastAPI
from sqlmodel import SQLModel, create_engine
app = FastAPI()
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)

# this is how we control what is done at startup and shutdown
@asynccontextmanager
async def lifespan(app: FastAPI):
    # startup logic comes here
    # Create the database and tables if they don't exist
    SQLModel.metadata.create_all(engine)

    yield
    # shutdown logic comes here
    # none so far


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
@app.get("/")
```

## !!steps 01 (2/2): creating a database with sqlmodel using a lifespan
### 00 -> 01 - changes in requirements.txt
#### add sqlmodel to the requirements

actually `requiremnts.txt` is a convenience only, to let people know what is needed to run the code  
a real application would probably use a `pyprojcet.toml` file to manage dependencies, but let's keep it simple for now
```text ! requirements.txt
!className(1) separator
!diff(3:3) +
........
fastapi[standard]
sqlmodel
```

```python ! main.py
# !className(1) separator
# !diff(4:4) +
# !diff(6:7) +
# !diff(9:9) +
# !className(12) separator
# !diff(14:21) +
........
VERSION = "00"
from contextlib import asynccontextmanager
from typing import Annotated
from fastapi import FastAPI
from fastapi import Depends

from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
    # none so far
# create a so-called "dependency" to get the database session
def get_session():
    with Session(engine) as session:
        yield session

SessionDep = Annotated[Session, Depends(get_session)]


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
```

```text ! .gitignore
!className(1) separator
!diff(4:4) +
........
__pycache__
.macnb/
notes.db
```

```python ! main.py
# !className(1) separator
# !diff(4:4) +
# !className(7) separator
# !diff(9:15) +
# !className(18) separator
# !diff(22:33) +
........
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
from sqlmodel import Field
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
SessionDep = Annotated[Session, Depends(get_session)]
class Note(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    description: str
    done: bool = False


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
........
async def root():
    return dict(message="Hello FastAPI World!",
                version=VERSION)

"""
http :8000/api/notes title="Devoirs" description="TP Backend"
http :8000/api/notes title="Papiers" description="Nouveau Passeport"
http :8000/api/notes title="Dentiste" description="ouille !" done:=true
"""
@app.post("/api/notes")
def create_note(note: Note, session: SessionDep) -> Note:
    session.add(note)
    session.commit()
    session.refresh(note)
    return note
```

```python ! main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(12:19) +
........
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
from sqlmodel import Field
from sqlmodel import select
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
    session.commit()
    session.refresh(note)
    return note

"""
http :8000/api/notes
"""
@app.get("/api/notes")
def get_notes(session: SessionDep) -> list[Note]:
    notes = session.exec(select(Note)).all()
    return notes
```

```python ! main.py
# !className(1) separator
# !diff(5:12) +
........
def get_notes(session: SessionDep) -> list[Note]:
    notes = session.exec(select(Note)).all()
    return notes

"""
http :8000/api/notes/1
"""
@app.get("/api/notes/{note_id}")
def get_note(note_id: int, session: SessionDep) -> Note | None:
    note = session.get(Note, note_id)
    return note
```

```python ! main.py
# !className(1) separator
# !diff(4:4) +
# !className(7) separator
# !diff(11:15) +
........
from fastapi import FastAPI
from fastapi import Depends
from fastapi.staticfiles import StaticFiles
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
def get_note(note_id: int, session: SessionDep) -> Note | None:
    note = session.get(Note, note_id)
    return note

"""
http :8000/static/css/style.css
"""
app.mount("/static", StaticFiles(directory="static"), name="static")
```

```css ! style.css
/* !diff(1:78) + */
:root {
  font-family: Arial, sans-serif;
  background-color: #f4f4f4;
}

body,
ul,
li {
  margin: 0;
  padding: 0;
}

ul,
li.note {
  list-style: none;
}

h1 {
  color: #333;
  font-size: 2em;
  text-align: center;
}

form {
  input[name="description"] {
    width: 100%;
    max-width: 40em;
    background: rgb(239, 186, 242);
    border-radius: 5px;
  }
}

.notes {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
  margin: 50px;

  .note {
    /* color:  */
    min-width: 10em;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    border-radius: 10px;
    margin: 10px;
    padding: 20px;
    background-color: #ffe0e0;
    border: 2px solid #922121;

    &:has(input:checked) {
      background-color: #e0ffe0;
      border: 1px solid #0e5825;
      opacity: 0.5;
    }

    .title {
      color: rgb(125, 4, 109);
      font-size: x-large;
      font-weight: 700;
      text-align: center;
      margin-bottom: 1em;
    }

    .line {
      display: flex;
      justify-content: space-between;

      span {
        margin-right: 1em;
      }
    }

    input[type="checkbox"] {
      width: 1.5em;
      height: 1.5em;
    }
  }
}
```

```python ! main.py
# !className(1) separator
# !diff(5:7) +
# !className(10) separator
# !diff(14:27) +
........
from fastapi import FastAPI
from fastapi import Depends
from fastapi.staticfiles import StaticFiles
from fastapi import Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
http :8000/static/css/style.css
"""
app.mount("/static", StaticFiles(directory="static"), name="static")


templates = Jinja2Templates(directory="templates")

"""
http :8000/front/notes
"""
@app.get("/front/notes", response_class=HTMLResponse)
def notes_page(request: Request, session: SessionDep):
    notes = session.exec(select(Note)).all()
    return templates.TemplateResponse(
        request=request,
        name="notes.html.j2",
        context={"notes": notes})
```

```html ! notes.html.j2
<!-- !diff(1:26) + -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/style.css">
    <title>My todo notes</title>
</head>

<body>
    <h1>My todo notes</h1>
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
            <div class="title">{{ note.title }}</div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%} />
            </div>
        </li>
        {% endfor %}
    </ul>
</body>

</html>
```

```python ! main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(11:12) -
# !diff(13:13) +
# !className(16) separator
# !diff(20:20) -
# !diff(21:21) +
........
from fastapi.staticfiles import StaticFiles
from fastapi import Request
from fastapi.responses import HTMLResponse
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, create_engine
........
@app.get("/")
async def root():
    return dict(message="Hello FastAPI World!",
                version=VERSION)
    return RedirectResponse(url="/front/notes")
"""
http :8000/api/notes title="Devoirs" description="TP Backend"
........
    return templates.TemplateResponse(
        request=request,
        name="notes.html.j2",
        context={"notes": notes})
        context={"version": VERSION, "notes": notes})
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:4) - -->
<!-- !diff(5:5) + -->
........
</head>
<body>
    <h1>My todo notes</h1>
    <h1>My todo notes v{{version}}</h1>
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
```

```python ! main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(10:11) +
# !className(15) separator
# !diff(19:41) +
........
from fastapi.responses import HTMLResponse
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi import Body
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
SessionDep = Annotated[Session, Depends(get_session)]
# for now we'll use a single type for all operations on notes
# BUT we'll see later on how to improve that
class Note(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
........
        request=request,
        name="notes.html.j2",
        context={"version": VERSION, "notes": notes})


"""
http PATCH :8000/api/notes/1 done:=true
http PATCH :8000/api/notes/1 description="TP Backend FastAPI"
"""
@app.patch("/api/notes/{note_id}", response_model=Note)
def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[Note, Body(...)],
):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # a class-independant way to do the update
    db_note.sqlmodel_update(payload.model_dump(exclude_unset=True))
    # commit the changes to the database
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    # return the updated note
    return db_note
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(5:5) - -->
<!-- !diff(6:7) + -->
<!-- !diff(12:13) + -->
........
            <div class="title">{{ note.title }}</div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%} />
                <input type="checkbox" {% if note.done %}checked{%endif%}
                    onchange="note_done_changed(this, {{ note.id }})" />
            </div>
        </li>
        {% endfor %}
    </ul>

    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
</body>
</html>
```

```js ! update-backend.js
// !diff(1:20) +
// the callback attached to clicking the "done" checkbox
// it is used verbatim in the HTML template
async function note_done_changed(elt, nodeId) {
    const done = elt.checked
    const url = `/api/notes/${nodeId}`
    const data = { done: done }
    const response = await fetch(url, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    })
    if (response.ok) {
      const data = await response.json()
      console.log(`${url} returned`, data)
    } else {
      console.error("Error updating note done status:", response.statusText)
    }
  }
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:12) + -->
<!-- !className(16) separator -->
<!-- !diff(19:19) + -->
........
<body>
    <h1>My todo notes v{{version}}</h1>
    <form id="add-note-form" action="/api/notes" method="POST">
        <fieldset>
            <legend>Add a new note</legend>
            <input type="text" name="title" placeholder="Title" required>
            <input type="text" name="description" placeholder="Description" required>
            <button type="submit">Add Note</button>
        </fieldset>
    </form>

    <ul class="notes">
        {% for note in notes %}
        <li class="note">
........
    </ul>
    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
    <script src="{{ url_for('static', path='/js/forms-use-json.js') }}"></script>
</body>
</html>
```

```js ! forms-use-json.js
// !diff(1:26) +
// reprogram all forms to send their fields as JSON

document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll('form').forEach((form) => {
        const formToJSON = form => Object.fromEntries(new FormData(form))
        form.addEventListener("submit", async (event) => {
          event.preventDefault()

          // use the action= attribute of the <form>
          //  to determine where to send the data
          const action = form.action
          const json = formToJSON(form)
          const response = await fetch(action, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(json),
          })
          if (!response.ok) {
            console.error(`Error submitting form at ${action} : `, response.statusText)
            return
          }
          const decoded = await response.json()
          console.log("response", decoded)
        })
      })
    })
```

```python ! main.py
# !className(1) separator
# !diff(5:18) +
........
    session.refresh(db_note)
    # return the updated note
    return db_note


"""
http DELETE :8000/api/notes/3
"""
@app.delete("/api/notes/{note_id}")
def delete_note(note_id: int, session: SessionDep):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # delete the note
    session.delete(db_note)
    session.commit()
    return db_note
```

```js ! update-backend.js
// !className(1) separator
// !diff(5:21) +
........
      console.error("Error updating note done status:", response.statusText)
    }
  }


async function note_delete(elt, nodeId) {
  const url = `/api/notes/${nodeId}`;
  const response = await fetch(url, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json",
    },
  });
  if (response.ok) {
    const data = await response.json();
    console.log(`${url} returned`, data);
  } else {
    console.error("Error deleting note:", response.statusText);
  }
}
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(5:5) - -->
<!-- !diff(6:8) + -->
........
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
            <div class="title">{{ note.title }}</div>
            <div class="title">{{ note.title }}
                <button class="delete-button" onclick="note_delete(this, {{ note.id }})">🗑</button>
            </div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%}
```

```python ! main.py
# !className(1) separator
# !diff(3:5) -
# !diff(6:16) +
# !diff(18:20) -
........
SessionDep = Annotated[Session, Depends(get_session)]
# for now we'll use a single type for all operations on notes
# BUT we'll see later on how to improve that
class Note(SQLModel, table=True):
# in this version we define several models for a note
# that describe which fields exactly we want to support / expose
# in each operation of the API
class NoteCreate(SQLModel):
    title: str | None = Field(default=None, description="le titre de la note")
    description: str | None = Field(default=None, description="Le texte de la note")

class NoteUpdate(NoteCreate):
    done: bool = Field(default=False, description="La tâche est-elle terminée ?")

class Note(NoteUpdate, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    description: str
    done: bool = False
# Create the FastAPI app with the lifespan context manager
```

```python ! main.py
# !className(1) separator
# !diff(5:5) -
# !diff(6:6) +
# !diff(9:10) -
# !diff(11:13) +
# !diff(15:16) -
# !diff(17:18) +
# !className(21) separator
# !diff(25:25) -
# !diff(26:26) +
........
"""
http :8000/api/notes title="Devoirs" description="TP Backend"
http :8000/api/notes title="Papiers" description="Nouveau Passeport"
http :8000/api/notes title="Dentiste" description="ouille !" done:=true
http :8000/api/notes title="Dentiste" description="ouille !"
"""
@app.post("/api/notes")
def create_note(note: Note, session: SessionDep) -> Note:
    session.add(note)
def create_note(note: NoteCreate, session: SessionDep) -> Note:
    db_note = Note.model_validate(note)
    session.add(db_note)
    session.commit()
    session.refresh(note)
    return note
    session.refresh(db_note)
    return db_note
"""
http :8000/api/notes
........
def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[Note, Body(...)],
    payload: Annotated[NoteUpdate, Body(...)],
):
    db_note = session.get(Note, note_id)
    if not db_note:
```

```python ! main.py
# !className(1) separator
# !diff(5:10) +
........
from sqlmodel import Session
from sqlmodel import Field
from sqlmodel import select

from broadcaster import WebSocketBroadcaster

# create a singleton object
websocket_broadcaster = WebSocketBroadcaster()

SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
```

```python ! broadcaster.py
# !diff(1:34) +
from typing import Literal

import asyncio

from fastapi import WebSocket

Action = Literal["create", "update", "delete"]

class WebSocketBroadcaster:
    """
    registers active websocket connections
    and broadcasts messages to all of them
    """
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)

    # cannot import Note here, to avoid circular import
    async def broadcast(self, action: Action, note: "Note"):
        payload = { "action": action, "note": dict(note) }
        coros = [ws.send_json(payload) for ws in self.active_connections]
        results = await asyncio.gather(*coros, return_exceptions=True)

        # Clean up any that failed
        for ws, result in zip(self.active_connections.copy(), results):
            if isinstance(result, Exception):
                self.disconnect(ws)
```

```python ! main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(12:22) +
........
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi import Body
from fastapi import WebSocket, WebSocketDisconnect
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
    session.delete(db_note)
    session.commit()
    return db_note


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket_broadcaster.connect(websocket)
    try:
        while True:
            # Optional: handle incoming messages if you want, or just keep alive
            await websocket.receive_text()
    except WebSocketDisconnect:
        websocket_broadcaster.disconnect(websocket)
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:4) + -->
........
    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
    <script src="{{ url_for('static', path='/js/forms-use-json.js') }}"></script>
    <script src="{{ url_for('static', path='/js/ws-listener.js') }}"></script>
</body>
</html>
```

```js ! ws-listener.js
// !diff(1:23) +
document.addEventListener("DOMContentLoaded",
    // connect to the WebSocket server on page load
    () => {
        const ws = new WebSocket(`ws://${window.location.host}/ws`);

        ws.onopen = () => {
            console.log("WebSocket connection opened");
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log("Received data:", data);
        };

        ws.onclose = () => {
            console.log("WebSocket connection closed");
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
        };
    }
)
```

```python ! main.py
# !className(1) separator
# !diff(5:5) -
# !diff(6:6) +
# !diff(11:11) +
# !className(14) separator
# !diff(18:18) -
# !diff(19:19) +
# !className(23) separator
# !diff(27:27) +
# !className(30) separator
# !diff(34:34) -
# !diff(35:35) +
# !diff(42:42) +
........
http :8000/api/notes title="Dentiste" description="ouille !"
"""
@app.post("/api/notes")
def create_note(note: NoteCreate, session: SessionDep) -> Note:
async def create_note(note: NoteCreate, session: SessionDep) -> Note:
    db_note = Note.model_validate(note)
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    await websocket_broadcaster.broadcast(action="create", note=db_note)
    return db_note
"""
........
http PATCH :8000/api/notes/1 description="TP Backend FastAPI"
"""
@app.patch("/api/notes/{note_id}", response_model=Note)
def update_note(
async def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[NoteUpdate, Body(...)],
........
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    await websocket_broadcaster.broadcast(action="update", note=db_note)
    # return the updated note
    return db_note
........
http DELETE :8000/api/notes/3
"""
@app.delete("/api/notes/{note_id}")
def delete_note(note_id: int, session: SessionDep):
async def delete_note(note_id: int, session: SessionDep):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # delete the note
    session.delete(db_note)
    session.commit()
    await websocket_broadcaster.broadcast(action="delete", note=db_note)
    return db_note
```

```js ! ws-listener.js
// !className(1) separator
// !diff(5:19) +
........
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log("Received data:", data);
            // Handle the received data as needed
            const { action, note } = data;
            switch (action) {
                case "create":
                    createNoteElement(note);
                    break;
                case "update":
                    updateNoteElement(note);
                    break;
                case "delete":
                    deleteNoteElement(note.id);
                    break;
                default:
                    console.warn("Unknown action:", action);
            }
        };
        ws.onclose = () => {
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(5:5) + -->
........
    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
    <script src="{{ url_for('static', path='/js/forms-use-json.js') }}"></script>
    <script src="{{ url_for('static', path='/js/ws-listener.js') }}"></script>
    <script src="{{ url_for('static', path='/js/clientside-rendering.js') }}"></script>
</body>
</html>
```

```js ! clientside-rendering.js
// !diff(1:11) +
function createNote(note) {
    console.log("Creating note:", note);
}

function updateNote(note) {
    console.log("Updating note:", note);
}

function deleteNote(noteId) {
    console.log("Deleting note with ID:", noteId);
}
```

```html ! notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:4) - -->
<!-- !diff(5:5) + -->
........
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
        <li id="note-{{note.id}}" class="note">
            <div class="title">{{ note.title }}
                <button class="delete-button" onclick="note_delete(this, {{ note.id }})">🗑</button>
            </div>
```

```js ! clientside-rendering.js
// !className(1) separator
// !diff(2:3) -
// !diff(4:19) +
........
function createNote(note) {
    console.log("Creating note:", note);
function createNoteElement(note) {
    const elt = document.createElement("li");
    elt.classList.add("note");
    elt.id = `note-${note.id}`;
    const html = `
    <div class="title">${note.title}
        <button class="delete-button" onclick="note_delete(this, ${note.id})">🗑</button>
    </div>
    <div class="line">
        <span>${note.description}</span>
        <input type="checkbox" ${note.done ? "checked" : ""}
        onchange="note_done_changed(this, ${note.id})" />
    </div>
`
    elt.innerHTML = html;
    document.querySelector("ul.notes").appendChild(elt);
}
function updateNote(note) {
```

```js ! clientside-rendering.js
// !className(1) separator
// !diff(4:5) -
// !diff(6:15) +
........
    document.querySelector("ul.notes").appendChild(elt);
}
function updateNote(note) {
    console.log("Updating note:", note);
function updateNoteElement(note) {
    const id = note.id;
    const elt = document.querySelector(`#note-${id}`);
    if (!elt) {
        console.warn("Note element not found for ID:", id);
        return;
    }
    elt.querySelector(".title").textContent = note.title;
    elt.querySelector("span").textContent = note.description;
    elt.querySelector("input[type='checkbox']").checked = note.done ? "checked" : "";
}
function deleteNote(noteId) {
```

```js ! clientside-rendering.js
// !className(1) separator
// !diff(4:5) -
// !diff(6:12) +
........
    elt.querySelector("input[type='checkbox']").checked = note.done ? "checked" : "";
}
function deleteNote(noteId) {
    console.log("Deleting note with ID:", noteId);
function deleteNoteElement(noteId) {
    const elt = document.querySelector(`#note-${noteId}`);
    if (elt) {
        elt.remove();
    } else {
        console.warn("Note element not found for ID:", noteId);
    }
}
```



## !outro conclusion

### some illustrations

![](front-users.excalidraw.svg)
![](socketio.excalidraw.svg)

### after thoughts

it seems that the choice of our endpoints is not necessarily in line with common practice;
the following renaming has been suggested:

- `/api/messages/1/` to send a message from user 1, with the other message fields (like `recipient_id`)
  passed in the POST JSON data


### further work

from this, you can now improve this code to support actual (multi-people) rooms;
2 levels of involvement can be envisioned

1. Just write the steps that would be needed, in mush the same way as above
1. and/or if you're up for it, go as far as implementing it