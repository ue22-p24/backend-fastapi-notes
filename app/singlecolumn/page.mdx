import Link from 'next/link'
import TableOfContents from '../components/tableofcontents'
import TableOfContentsItem from '../components/tableofcontentsitem'

<TableOfContents />

# Chat App step by step (single column)

<Link href="/">Back to top</Link>

please see the warning, as well as the code repo locations, at the top of the [scrollycoding page](scrollycoding/)

## step 00: the starter code

the starter code in step 00 is the basic FastAPI `hello world` app

```python app.py
!from ../app-00.py
```

<TableOfContentsItem topic='step 01 - 1/2 eating a database with sqlmodel using a lifespan' label='01 eating a database with sqlmodel using a lifespan'>
```python main.py
# !className(1) separator
# !diff(3:4) +
# !diff(6:6) +
# !diff(7:7) -
# !diff(8:24) +
........
VERSION = "00"
from contextlib import asynccontextmanager

from fastapi import FastAPI
from sqlmodel import SQLModel, create_engine
app = FastAPI()
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)

# this is how we control what is done at startup and shutdown
@asynccontextmanager
async def lifespan(app: FastAPI):
    # startup logic comes here
    # Create the database and tables if they don't exist
    SQLModel.metadata.create_all(engine)

    yield
    # shutdown logic comes here
    # none so far


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
@app.get("/")
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 01 - 2/2 eating a database with sqlmodel using a lifespan' label='01 - 2/2'>
```text requirements.txt
!className(1) separator
!diff(3:3) +
........
fastapi[standard]
sqlmodel
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 01b -  fine SessionDep for  interacting with the DB' label='01b fine SessionDep for  interacting with the DB'>
```python main.py
# !className(1) separator
# !diff(4:4) +
# !diff(6:7) +
# !diff(9:9) +
# !className(12) separator
# !diff(14:21) +
........
VERSION = "00"
from contextlib import asynccontextmanager
from typing import Annotated
from fastapi import FastAPI
from fastapi import Depends

from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
    # none so far
# create a so-called "dependency" to get the database session
def get_session():
    with Session(engine) as session:
        yield session

SessionDep = Annotated[Session, Depends(get_session)]


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 02 - 1/2 table for notes + a POST /api/notes endpoint' label='02 table for notes + a POST /api/notes endpoint'>
```text .gitignore
!className(1) separator
!diff(4:4) +
........
__pycache__
.macnb/
notes.db
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 02 - 2/2 table for notes + a POST /api/notes endpoint' label='02 - 2/2'>
```python main.py
# !className(1) separator
# !diff(4:4) +
# !className(7) separator
# !diff(9:15) +
# !className(18) separator
# !diff(22:33) +
........
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
from sqlmodel import Field
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
SessionDep = Annotated[Session, Depends(get_session)]
class Note(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    description: str
    done: bool = False


# Create the FastAPI app with the lifespan context manager
app = FastAPI(lifespan=lifespan)
........
async def root():
    return dict(message="Hello FastAPI World!",
                version=VERSION)

"""
http :8000/api/notes title="Devoirs" description="TP Backend"
http :8000/api/notes title="Papiers" description="Nouveau Passeport"
http :8000/api/notes title="Dentiste" description="ouille !" done:=true
"""
@app.post("/api/notes")
def create_note(note: Note, session: SessionDep) -> Note:
    session.add(note)
    session.commit()
    session.refresh(note)
    return note
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 02b -  T /api/notes endpoint' label='02b T /api/notes endpoint'>
```python main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(12:19) +
........
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
from sqlmodel import Field
from sqlmodel import select
SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
........
    session.commit()
    session.refresh(note)
    return note

"""
http :8000/api/notes
"""
@app.get("/api/notes")
def get_notes(session: SessionDep) -> list[Note]:
    notes = session.exec(select(Note)).all()
    return notes
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 02c -  T /api/notes/{i} endpoint' label='02c T /api/notes/{i} endpoint'>
```python main.py
# !className(1) separator
# !diff(5:12) +
........
def get_notes(session: SessionDep) -> list[Note]:
    notes = session.exec(select(Note)).all()
    return notes

"""
http :8000/api/notes/1
"""
@app.get("/api/notes/{note_id}")
def get_note(note_id: int, session: SessionDep) -> Note | None:
    note = session.get(Note, note_id)
    return note
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 03 - 1/2 pose /static/ folder with the CSS style' label='03 pose /static/ folder with the CSS style'>
```python main.py
# !className(1) separator
# !diff(4:4) +
# !className(7) separator
# !diff(11:15) +
........
from fastapi import FastAPI
from fastapi import Depends
from fastapi.staticfiles import StaticFiles
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
def get_note(note_id: int, session: SessionDep) -> Note | None:
    note = session.get(Note, note_id)
    return note

"""
http :8000/static/css/style.css
"""
app.mount("/static", StaticFiles(directory="static"), name="static")
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 03 - 2/2 pose /static/ folder with the CSS style' label='03 - 2/2'>
```css style.css
/* !diff(1:78) + */
:root {
  font-family: Arial, sans-serif;
  background-color: #f4f4f4;
}

body,
ul,
li {
  margin: 0;
  padding: 0;
}

ul,
li.note {
  list-style: none;
}

h1 {
  color: #333;
  font-size: 2em;
  text-align: center;
}

form {
  input[name="description"] {
    width: 100%;
    max-width: 40em;
    background: rgb(239, 186, 242);
    border-radius: 5px;
  }
}

.notes {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
  margin: 50px;

  .note {
    /* color:  */
    min-width: 10em;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    border-radius: 10px;
    margin: 10px;
    padding: 20px;
    background-color: #ffe0e0;
    border: 2px solid #922121;

    &:has(input:checked) {
      background-color: #e0ffe0;
      border: 1px solid #0e5825;
      opacity: 0.5;
    }

    .title {
      color: rgb(125, 4, 109);
      font-size: x-large;
      font-weight: 700;
      text-align: center;
      margin-bottom: 1em;
    }

    .line {
      display: flex;
      justify-content: space-between;

      span {
        margin-right: 1em;
      }
    }

    input[type="checkbox"] {
      width: 1.5em;
      height: 1.5em;
    }
  }
}
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 03b - 1/2 T /front/notes returns templated HTML' label='03b T /front/notes returns templated HTML'>
```python main.py
# !className(1) separator
# !diff(5:7) +
# !className(10) separator
# !diff(14:27) +
........
from fastapi import FastAPI
from fastapi import Depends
from fastapi.staticfiles import StaticFiles
from fastapi import Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
http :8000/static/css/style.css
"""
app.mount("/static", StaticFiles(directory="static"), name="static")


templates = Jinja2Templates(directory="templates")

"""
http :8000/front/notes
"""
@app.get("/front/notes", response_class=HTMLResponse)
def notes_page(request: Request, session: SessionDep):
    notes = session.exec(select(Note)).all()
    return templates.TemplateResponse(
        request=request,
        name="notes.html.j2",
        context={"notes": notes})
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 03b - 2/2 T /front/notes returns templated HTML' label='03b - 2/2'>
```html notes.html.j2
<!-- !diff(1:26) + -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/style.css">
    <title>My todo notes</title>
</head>

<body>
    <h1>My todo notes</h1>
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
            <div class="title">{{ note.title }}</div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%} />
            </div>
        </li>
        {% endfor %}
    </ul>
</body>

</html>
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 04 - 1/2 direct / to /front/notes' label='04 direct / to /front/notes'>
```python main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(11:12) -
# !diff(13:13) +
# !className(16) separator
# !diff(20:20) -
# !diff(21:21) +
........
from fastapi.staticfiles import StaticFiles
from fastapi import Request
from fastapi.responses import HTMLResponse
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, create_engine
........
@app.get("/")
async def root():
    return dict(message="Hello FastAPI World!",
                version=VERSION)
    return RedirectResponse(url="/front/notes")
"""
http :8000/api/notes title="Devoirs" description="TP Backend"
........
    return templates.TemplateResponse(
        request=request,
        name="notes.html.j2",
        context={"notes": notes})
        context={"version": VERSION, "notes": notes})
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 04 - 2/2 direct / to /front/notes' label='04 - 2/2'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:4) - -->
<!-- !diff(5:5) + -->
........
</head>
<body>
    <h1>My todo notes</h1>
    <h1>My todo notes v{{version}}</h1>
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 05 -  TCH /api/notes endpoint to change a note' label='05 TCH /api/notes endpoint to change a note'>
```python main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(10:11) +
# !className(15) separator
# !diff(19:41) +
........
from fastapi.responses import HTMLResponse
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi import Body
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
SessionDep = Annotated[Session, Depends(get_session)]
# for now we'll use a single type for all operations on notes
# BUT we'll see later on how to improve that
class Note(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
........
        request=request,
        name="notes.html.j2",
        context={"version": VERSION, "notes": notes})


"""
http PATCH :8000/api/notes/1 done:=true
http PATCH :8000/api/notes/1 description="TP Backend FastAPI"
"""
@app.patch("/api/notes/{note_id}", response_model=Note)
def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[Note, Body(...)],
):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # a class-independant way to do the update
    db_note.sqlmodel_update(payload.model_dump(exclude_unset=True))
    # commit the changes to the database
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    # return the updated note
    return db_note
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 06 - 1/2 icking 'done' is published to the backend' label='06 icking 'done' is published to the backend'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(5:5) - -->
<!-- !diff(6:7) + -->
<!-- !diff(12:13) + -->
........
            <div class="title">{{ note.title }}</div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%} />
                <input type="checkbox" {% if note.done %}checked{%endif%}
                    onchange="note_done_changed(this, {{ note.id }})" />
            </div>
        </li>
        {% endfor %}
    </ul>

    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
</body>
</html>
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 06 - 2/2 icking 'done' is published to the backend' label='06 - 2/2'>
```js update-backend.js
// !diff(1:20) +
// the callback attached to clicking the "done" checkbox
// it is used verbatim in the HTML template
async function note_done_changed(elt, nodeId) {
    const done = elt.checked
    const url = `/api/notes/${nodeId}`
    const data = { done: done }
    const response = await fetch(url, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    })
    if (response.ok) {
      const data = await response.json()
      console.log(`${url} returned`, data)
    } else {
      console.error("Error updating note done status:", response.statusText)
    }
  }
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 07 - 1/2 e UI can create a note' label='07 e UI can create a note'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:12) + -->
<!-- !className(16) separator -->
<!-- !diff(19:19) + -->
........
<body>
    <h1>My todo notes v{{version}}</h1>
    <form id="add-note-form" action="/api/notes" method="POST">
        <fieldset>
            <legend>Add a new note</legend>
            <input type="text" name="title" placeholder="Title" required>
            <input type="text" name="description" placeholder="Description" required>
            <button type="submit">Add Note</button>
        </fieldset>
    </form>

    <ul class="notes">
        {% for note in notes %}
        <li class="note">
........
    </ul>
    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
    <script src="{{ url_for('static', path='/js/forms-use-json.js') }}"></script>
</body>
</html>
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 07 - 2/2 e UI can create a note' label='07 - 2/2'>
```js forms-use-json.js
// !diff(1:26) +
// reprogram all forms to send their fields as JSON

document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll('form').forEach((form) => {
        const formToJSON = form => Object.fromEntries(new FormData(form))
        form.addEventListener("submit", async (event) => {
          event.preventDefault()

          // use the action= attribute of the <form>
          //  to determine where to send the data
          const action = form.action
          const json = formToJSON(form)
          const response = await fetch(action, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(json),
          })
          if (!response.ok) {
            console.error(`Error submitting form at ${action} : `, response.statusText)
            return
          }
          const decoded = await response.json()
          console.log("response", decoded)
        })
      })
    })
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 08 -  LETE /api/notes/{i}' label='08 LETE /api/notes/{i}'>
```python main.py
# !className(1) separator
# !diff(5:18) +
........
    session.refresh(db_note)
    # return the updated note
    return db_note


"""
http DELETE :8000/api/notes/3
"""
@app.delete("/api/notes/{note_id}")
def delete_note(note_id: int, session: SessionDep):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # delete the note
    session.delete(db_note)
    session.commit()
    return db_note
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 09 - 1/2 e UI can delete a note' label='09 e UI can delete a note'>
```js update-backend.js
// !className(1) separator
// !diff(5:21) +
........
      console.error("Error updating note done status:", response.statusText)
    }
  }


async function note_delete(elt, nodeId) {
  const url = `/api/notes/${nodeId}`;
  const response = await fetch(url, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json",
    },
  });
  if (response.ok) {
    const data = await response.json();
    console.log(`${url} returned`, data);
  } else {
    console.error("Error deleting note:", response.statusText);
  }
}
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 09 - 2/2 e UI can delete a note' label='09 - 2/2'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(5:5) - -->
<!-- !diff(6:8) + -->
........
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
            <div class="title">{{ note.title }}</div>
            <div class="title">{{ note.title }}
                <button class="delete-button" onclick="note_delete(this, {{ note.id }})">ðŸ—‘</button>
            </div>
            <div class="line">
                <span>{{ note.description }}</span>
                <input type="checkbox" {% if note.done %}checked{%endif%}
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 10 -  ne-grained types NoteCreate NoteUpdate Note' label='10 ne-grained types NoteCreate NoteUpdate Note'>
```python main.py
# !className(1) separator
# !diff(3:5) -
# !diff(6:16) +
# !diff(18:20) -
........
SessionDep = Annotated[Session, Depends(get_session)]
# for now we'll use a single type for all operations on notes
# BUT we'll see later on how to improve that
class Note(SQLModel, table=True):
# in this version we define several models for a note
# that describe which fields exactly we want to support / expose
# in each operation of the API
class NoteCreate(SQLModel):
    title: str | None = Field(default=None, description="le titre de la note")
    description: str | None = Field(default=None, description="Le texte de la note")

class NoteUpdate(NoteCreate):
    done: bool = Field(default=False, description="La tÃ¢che est-elle terminÃ©e ?")

class Note(NoteUpdate, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    description: str
    done: bool = False
# Create the FastAPI app with the lifespan context manager
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 10a -  e the new types' label='10a e the new types'>
```python main.py
# !className(1) separator
# !diff(5:5) -
# !diff(6:6) +
# !diff(9:10) -
# !diff(11:13) +
# !diff(15:16) -
# !diff(17:18) +
# !className(21) separator
# !diff(25:25) -
# !diff(26:26) +
........
"""
http :8000/api/notes title="Devoirs" description="TP Backend"
http :8000/api/notes title="Papiers" description="Nouveau Passeport"
http :8000/api/notes title="Dentiste" description="ouille !" done:=true
http :8000/api/notes title="Dentiste" description="ouille !"
"""
@app.post("/api/notes")
def create_note(note: Note, session: SessionDep) -> Note:
    session.add(note)
def create_note(note: NoteCreate, session: SessionDep) -> Note:
    db_note = Note.model_validate(note)
    session.add(db_note)
    session.commit()
    session.refresh(note)
    return note
    session.refresh(db_note)
    return db_note
"""
http :8000/api/notes
........
def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[Note, Body(...)],
    payload: Annotated[NoteUpdate, Body(...)],
):
    db_note = session.get(Note, note_id)
    if not db_note:
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 11 - 1/2 e WebsocketBroadcaster class' label='11 e WebsocketBroadcaster class'>
```python main.py
# !className(1) separator
# !diff(5:10) +
........
from sqlmodel import Session
from sqlmodel import Field
from sqlmodel import select

from broadcaster import WebSocketBroadcaster

# create a singleton object
websocket_broadcaster = WebSocketBroadcaster()

SQLITE_URL = f"sqlite:///notes.db"
engine = create_engine(SQLITE_URL)
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 11 - 2/2 e WebsocketBroadcaster class' label='11 - 2/2'>
```python broadcaster.py
# !diff(1:34) +
from typing import Literal

import asyncio

from fastapi import WebSocket

Action = Literal["create", "update", "delete"]

class WebSocketBroadcaster:
    """
    registers active websocket connections
    and broadcasts messages to all of them
    """
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)

    # cannot import Note here, to avoid circular import
    async def broadcast(self, action: Action, note: "Note"):
        payload = { "action": action, "note": dict(note) }
        coros = [ws.send_json(payload) for ws in self.active_connections]
        results = await asyncio.gather(*coros, return_exceptions=True)

        # Clean up any that failed
        for ws, result in zip(self.active_connections.copy(), results):
            if isinstance(result, Exception):
                self.disconnect(ws)
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 11a -  s endpoint' label='11a s endpoint'>
```python main.py
# !className(1) separator
# !diff(5:5) +
# !className(8) separator
# !diff(12:22) +
........
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi import Body
from fastapi import WebSocket, WebSocketDisconnect
from sqlmodel import SQLModel, create_engine
from sqlmodel import Session
........
    session.delete(db_note)
    session.commit()
    return db_note


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket_broadcaster.connect(websocket)
    try:
        while True:
            # Optional: handle incoming messages if you want, or just keep alive
            await websocket.receive_text()
    except WebSocketDisconnect:
        websocket_broadcaster.disconnect(websocket)
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 11b - 1/2 ject ws-listener.js in template' label='11b ject ws-listener.js in template'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:4) + -->
........
    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
    <script src="{{ url_for('static', path='/js/forms-use-json.js') }}"></script>
    <script src="{{ url_for('static', path='/js/ws-listener.js') }}"></script>
</body>
</html>
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 11b - 2/2 ject ws-listener.js in template' label='11b - 2/2'>
```js ws-listener.js
// !diff(1:23) +
document.addEventListener("DOMContentLoaded",
    // connect to the WebSocket server on page load
    () => {
        const ws = new WebSocket(`ws://${window.location.host}/ws`);

        ws.onopen = () => {
            console.log("WebSocket connection opened");
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log("Received data:", data);
        };

        ws.onclose = () => {
            console.log("WebSocket connection closed");
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
        };
    }
)
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 12 -  e api endpoints broadcast the changes on WS' label='12 e api endpoints broadcast the changes on WS'>
```python main.py
# !className(1) separator
# !diff(5:5) -
# !diff(6:6) +
# !diff(11:11) +
# !className(14) separator
# !diff(18:18) -
# !diff(19:19) +
# !className(23) separator
# !diff(27:27) +
# !className(30) separator
# !diff(34:34) -
# !diff(35:35) +
# !diff(42:42) +
........
http :8000/api/notes title="Dentiste" description="ouille !"
"""
@app.post("/api/notes")
def create_note(note: NoteCreate, session: SessionDep) -> Note:
async def create_note(note: NoteCreate, session: SessionDep) -> Note:
    db_note = Note.model_validate(note)
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    await websocket_broadcaster.broadcast(action="create", note=db_note)
    return db_note
"""
........
http PATCH :8000/api/notes/1 description="TP Backend FastAPI"
"""
@app.patch("/api/notes/{note_id}", response_model=Note)
def update_note(
async def update_note(
    note_id: int,
    session: SessionDep,
    payload: Annotated[NoteUpdate, Body(...)],
........
    session.add(db_note)
    session.commit()
    session.refresh(db_note)
    await websocket_broadcaster.broadcast(action="update", note=db_note)
    # return the updated note
    return db_note
........
http DELETE :8000/api/notes/3
"""
@app.delete("/api/notes/{note_id}")
def delete_note(note_id: int, session: SessionDep):
async def delete_note(note_id: int, session: SessionDep):
    db_note = session.get(Note, note_id)
    if not db_note:
        raise HTTPException(status_code=404, detail=f"Note {note_id} not found")
    # delete the note
    session.delete(db_note)
    session.commit()
    await websocket_broadcaster.broadcast(action="delete", note=db_note)
    return db_note
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13 - 1/3 ndle incoming WS messages in the frontend' label='13 ndle incoming WS messages in the frontend'>
```js ws-listener.js
// !className(1) separator
// !diff(5:19) +
........
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log("Received data:", data);
            // Handle the received data as needed
            const { action, note } = data;
            switch (action) {
                case "create":
                    createNoteElement(note);
                    break;
                case "update":
                    updateNoteElement(note);
                    break;
                case "delete":
                    deleteNoteElement(note.id);
                    break;
                default:
                    console.warn("Unknown action:", action);
            }
        };
        ws.onclose = () => {
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13 - 2/3 ndle incoming WS messages in the frontend' label='13 - 2/3'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(5:5) + -->
........
    <script src="{{ url_for('static', path='/js/update-backend.js') }}"></script>
    <script src="{{ url_for('static', path='/js/forms-use-json.js') }}"></script>
    <script src="{{ url_for('static', path='/js/ws-listener.js') }}"></script>
    <script src="{{ url_for('static', path='/js/clientside-rendering.js') }}"></script>
</body>
</html>
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13 - 3/3 ndle incoming WS messages in the frontend' label='13 - 3/3'>
```js clientside-rendering.js
// !diff(1:11) +
function createNote(note) {
    console.log("Creating note:", note);
}

function updateNote(note) {
    console.log("Updating note:", note);
}

function deleteNote(noteId) {
    console.log("Deleting note with ID:", noteId);
}
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13b -  fine id=note-{id} to the note &lt;li&gt;' label='13b fine id=note-{id} to the note &lt;li&gt;'>
```html notes.html.j2
<!-- !className(1) separator -->
<!-- !diff(4:4) - -->
<!-- !diff(5:5) + -->
........
    <ul class="notes">
        {% for note in notes %}
        <li class="note">
        <li id="note-{{note.id}}" class="note">
            <div class="title">{{ note.title }}
                <button class="delete-button" onclick="note_delete(this, {{ note.id }})">ðŸ—‘</button>
            </div>
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13c -  R on note creation' label='13c R on note creation'>
```js clientside-rendering.js
// !className(1) separator
// !diff(2:3) -
// !diff(4:19) +
........
function createNote(note) {
    console.log("Creating note:", note);
function createNoteElement(note) {
    const elt = document.createElement("li");
    elt.classList.add("note");
    elt.id = `note-${note.id}`;
    const html = `
    <div class="title">${note.title}
        <button class="delete-button" onclick="note_delete(this, ${note.id})">ðŸ—‘</button>
    </div>
    <div class="line">
        <span>${note.description}</span>
        <input type="checkbox" ${note.done ? "checked" : ""}
        onchange="note_done_changed(this, ${note.id})" />
    </div>
`
    elt.innerHTML = html;
    document.querySelector("ul.notes").appendChild(elt);
}
function updateNote(note) {
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13d -  R on note update' label='13d R on note update'>
```js clientside-rendering.js
// !className(1) separator
// !diff(4:5) -
// !diff(6:15) +
........
    document.querySelector("ul.notes").appendChild(elt);
}
function updateNote(note) {
    console.log("Updating note:", note);
function updateNoteElement(note) {
    const id = note.id;
    const elt = document.querySelector(`#note-${id}`);
    if (!elt) {
        console.warn("Note element not found for ID:", id);
        return;
    }
    elt.querySelector(".title").textContent = note.title;
    elt.querySelector("span").textContent = note.description;
    elt.querySelector("input[type='checkbox']").checked = note.done ? "checked" : "";
}
function deleteNote(noteId) {
```

</TableOfContentsItem>
<TableOfContentsItem topic='step 13e -  R on note deletion' label='13e R on note deletion'>
```js clientside-rendering.js
// !className(1) separator
// !diff(4:5) -
// !diff(6:12) +
........
    elt.querySelector("input[type='checkbox']").checked = note.done ? "checked" : "";
}
function deleteNote(noteId) {
    console.log("Deleting note with ID:", noteId);
function deleteNoteElement(noteId) {
    const elt = document.querySelector(`#note-${noteId}`);
    if (elt) {
        elt.remove();
    } else {
        console.warn("Note element not found for ID:", noteId);
    }
}
```

</TableOfContentsItem>


## conclusion

see the conclusion at the bottom of the [scrollycoding page](scrollycoding/)